Глобально у нас есть три задачи:

* Сбор информации с различных датчиков
* Анализ состояния системы
* Управление двигателями для изменения положения в пространстве. 

Центральный компонент это блок управления на базе одноплатного компьютера. Будем ориентироваться на RPI5 и Orange PI 5 plus.

На входе у нас могут быть следующие источники информации:

* Камера
* Лидар
* Датчик линии
* Датчик расстояния
* Энкодеры моторов

На выходе мы управляем моторами:

* Драйвер моторов

В итоге мы получаем следующую организацию компонентов:

![Централизованное управление.svg](%D0%A6%D0%B5%D0%BD%D1%82%D1%80%D0%B0%D0%BB%D0%B8%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5%20%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5.svg)

Такая схема работы имеет ряд недостатков:

* Для работы датчиками часто нужен аналогово-цифровой преобразователь. 
У одноплатников АЦП либо отсутствует, либо имеет ограничения. В Raspberry PI АЦП нет.
* Работа с энкодерами моторов требуется формирование импульсов широтно-импульсной модуляции. 
В одноплатниках поддержка шим ограничена. Например на Raspberry PI есть только два аппаратных канала, остальные программные. 
* Низкоуровневая работа с периферией будет отнимать ресурсы от высокоуровневой работы. 

Поэтому мы выносим часть логики управления в отдельные компоненты — блок моторов и блок датчиков. 

Это позволит нам реализовать низкоуровневое управление с помощью микроконтроллеров, таких как Arduino. 
В микроконтроллерах есть как аппаратная реализация ШИМ, так и АЦП. Таким образом мы получаем гибкую архитектуру 
с возможностью оптимизировать и заменять компоненты внутри блоков без влияния на всю систему. 
При необходимости можно будет менять как одноплатник, так и контроллеры. Например, вместо Arduino можно использовать 
более продвинутые и мощные платы Bluepill или Blackpill на контроллере STM, а вместо малины использовать 
Orange PI 5 plus с нейропроцессором для аппаратного ускорения работы AI и нейросетей.

Получаем децентрализованную схему:

![Децентрализованное управление 1.svg](%D0%94%D0%B5%D1%86%D0%B5%D0%BD%D1%82%D1%80%D0%B0%D0%BB%D0%B8%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5%20%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%201.svg)

В этом варианте часть устройств подключается напрямую к центральному блоку управления, а остальные к 
контроллерам. Каждый контроллер управлять различным количеством устройств в зависимости от ситуации. 
Количество контроллеров также может меняться.

Мы определили точки взаимодействия между компонентами. Далее необходимо определить физический интерфейс для подключения
устройств и контроллеров. Пока ограничимся описанием для основного блока. Работу контроллеров с устройствами можно 
рассмотреть позднее при детальной проработке внутренней схемы управляемых блоков.


Камеру напрямую подключаем к одноплатнику по интерфейсу CSI (Camera Serial Interface).

Лидар тоже подключаем напрямую через серийный порт. Возможно позже это 

Для взаиможействия между контроллерами и одноплатником есть следующие варианты: SPI, UART, USB, I2C. Нам необходимо подключить минимум два контроллера, а в будущем возможно и больше поэтому важно это учесть при выборе интерфейса. Для нас важны следующие параметры:
• Сложность подключения (количество проводов для подключения, необходимость преобразователей уровней напряжения
• Количество устройств подключаемых к одному физическому интерфейсу
• Количество физических интерфейсов на RPI и Orange PI
• Пропускная способность
• Поддержка в ROS.
SPI исключаем так как он требует пять проводов для подключения каждого устройства. При этом четыре общих провода и пятый отдельно для каждого устройства. Это неудобно и занимает пины на одноплатнике.
UART требует два провода и на каждое устройство требуется отдельный порт. На Raspberry 5 доступно шесть UART портов. Из них четыре аппаратных и два программных.
USB подходит в варианте USB-UART. Есть четыре порта USB.
I2C
Как блоки общаются между собой — сравнение протоколов

![Децентрализованное управление 2.svg](%D0%94%D0%B5%D1%86%D0%B5%D0%BD%D1%82%D1%80%D0%B0%D0%BB%D0%B8%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5%20%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%202.svg)

